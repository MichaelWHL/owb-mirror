pour mémoire:
- faire scripts pour récupérer les noms de classes/types/enum ET FONCTIONS DEFINIS (et non pas seulement déclarés) dans:
    - WebCore non BAL    => fichier1
        Files concerned: nonbalFiles.txt

    - BAL                => fichier2
        Files concerned: balInputFiles.txt

- récupérer les noms des types... UTILISES dans BAL/ fichier3
    - fichier3 - fichier1 - fichier2 => liste des types à BALtype ifier.  (verbe du 1° grouper, 'mordre', => 'er' à la fin) ;)
    faire une correspondance entre nameOrigine => BALname (gchar => BALchar)

Here stands few generators:
File balInputList contains all WebCore files path and BAL target that will be balified. It is eavily used by generators to generate BAL/skeletons

- balifier
    => WebKit files that are moved/modified to fit BAL standard:
    - namespace is WKAL (WebKit Abstraction Layer) or OWBAL (Origyn Web Browser Abstraction Layer) instead of WebCore, WTF.
        WKAL contains all that is dependant of WebKit
        OWBAL contains all that is independant of WebKit (and that may be reused out of WebKit)
    - all classes names are modified as this: class Foobar => #define BCFoobar Foobar; class Foobar (BC = BAL Concretization)
    - as namespace changed:
        - all WebCore objects that are not balified must be explicitly namespaced (adding WebCore::) into the new namespace
        - we propagate names into origin namespace ( namespace WebCore{using WKAL::BCFoobar;} )
    - a new config.h file is created to allow namespace propagation:
            namespace OWBAL{ class Foobar;}
            namespace WebCore{using OWBAL::Foobar;}
        This file is included from all WebKit files

    - in OWBAL, if in skeletons methods names are modified, balified WebKit files must be patched to keep them working outside WebKit.
    - all classes (Foobar) will inherit from a BD (BDFoobar), that will contain BalDebug things (using DeepSee for exemple)

- skeleton
    => a documented file skeleton that will be used to generate new concretization
    It defines the API with its doxygen documentation
    It is generated by scripts, from balInputList
    - it references the source file in comment
    - It gets all GTK API, as it is the more complete
    - all specific types are replaced by defined BAL types (WidgetGTK => BALWidget)
    - remove all #if PLATFORM, keep blocks for GTK, CAIRO, ICU, CURL
    - remove all #include that refers files outside BAL/WebKit (if WebKit files, namespace must be WKAL)
    - clean all gtk references (GtkWidget* gtkWidget() const; => BALWidget* balWidget() const;)
    - as it is NOT file intended to be compiled, no implementation will be given.
    - add types defs (see concretization for details)
         #include "configTypesCommon.h"
         #include "configTypes.h"


- concretization
    => generated from skeletons
    => it generates a BCFoobar.h and a BCFoobar.cpp that only contains empty methods (Foobar::Foobar(){BAL_NOT_IMPLEMENTED;})
    => for a generation, a list of skeletons to concretize must be provided (for exemple, for SDL, only few of them will be used)

    - do same work for namespaces as in balfified WebKit files (using, ...)
    - all BALtypes are defined in a concretization side header (for GTK: #define BALWidget WidgetGTK)
        BAL/Base/Gtk/configTypes.h
        BAL/Base/SDL/configTypes.h
        BAL/Base/configTypesCommon.h    => all common types (int, bool,
        BAL/Base/configTypes.h             => contains things like that: #if PLATFORM(GTK) #include configTypesGtk.h #endif

    - user just has to fill empty spaces ;) too easy!
